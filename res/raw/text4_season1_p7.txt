import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import android.app.Dialog;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

//قسمتهای جدید که به کد بازی اضافه شده اند شرح داده میشوند . سایر قسمتهای کد در بخشهای قبل شرح داده شده اند :
public class GameView extends View{
  
  private Context myContext;
  
  private List<Card> deck = new ArrayList<Card>();
  private List<Card> myHand = new ArrayList<Card>();
  private List<Card> oppHand = new ArrayList<Card>();

  private List<Card> discardPile = new ArrayList<Card>();

  private int scaledCardW;
  private int scaledCardH;
  private int screenW;
  private int screenH;
  
  private float scale;
  
  private Paint whitePaint;
  
  private int oppScore;
  private int myScore;
  
  private Bitmap cardBack;
  
  private boolean myTurn;
  
  private int movingCardIdx = -1;
  private int movingX;
  private int movingY;
  
  private int validSuit;
  private int validRank;

//تعریف یک متغیر بمنظور نشان دادن ردیف اضافه شونده به کارتهای بازی در دست بازیکن که بعلت زیادتر شدن از عرض صفحه نمایش ، بشکل پنهان شونده در صفحه نمایش نشان داده میشوند :
  private Bitmap nextCardButton;
  
  private Boolean canDraw;
  
  
  public GameView(Context context){
    super(context);
    myContext = context;
    scale = myContext.getResources().getDisplayMetrics().
density;
 whitePaint = new Paint(); 
 whitePaint.setAntiAlias(true); 
 whitePaint.setColor(Color.WHITE);
 whitePaint.setStyle(Paint.Style.STROKE);
 whitePaint.setTextAlign(Paint.Align.LEFT);
 whitePaint.setTextSize(scale*15);

 
 myTurn = true;
  }
  
  
  
    @Override
    public void onSizeChanged (int w, int h, int oldw, int oldh){
        super.onSizeChanged(w, h, oldw, oldh);
        screenW = w;
        screenH = h;
     
     initCards();
     
     dealCards();
     
   drawCard(discardPile);
     
     Bitmap tempBitmap = 
BitmapFactory.decodeResource
(myContext.getResources(),
R.drawable.card_back);
scaledCardW = (int) (screenW/8);
scaledCardH = (int) (scaledCardW*1.28);
cardBack = Bitmap.createScaledBitmap
(tempBitmap, scaledCardW, 
scaledCardH,false);


validSuit = discardPile.get(0).getSuit(); 
 validRank = discardPile.get(0).getRank();
 
 
	nextCardButton = BitmapFactory.decodeResource(getResources(), R.drawable.arrow_next); 
	
       }
       
       
  
  protected void onDraw(Canvas canvas){
    
    	canvas.drawRGB(268,69,93);
    
   		canvas.drawText("Computer Score: " + Integer.toString(oppScore), 10, whitePaint.getTextSize()+10, whitePaint);		
		canvas.drawText("My Score: " + Integer.toString(myScore), 10, screenH-whitePaint.getTextSize()-30, whitePaint);
  
  
  
  for (int i = 0; i < myHand.size(); i++) {
 if (i < 7) {
 canvas.drawBitmap(myHand.get(i).getBitmap(),
 i*(scaledCardW+5),
 screenH-scaledCardH-
 whitePaint.getTextSize()-(50*scale),
 null);
 }
 }
 
 for (int i = 0; i < oppHand.size(); i++) {
 canvas.drawBitmap(cardBack,
 i*(scale*5),
 whitePaint.getTextSize()+(50*scale),
 null);
}
 
 
 canvas.drawBitmap(cardBack, 
(screenW/2)-cardBack.getWidth()-10, 
(screenH/2)-(cardBack.getHeight()/2), null);
 
 
 
   if (!discardPile.isEmpty()) {
  canvas.drawBitmap(discardPile.get(0).getBitmap(),
(screenW/2)+10,
(screenH/2)-(cardBack.getHeight()/2),
null);
    } 
 
 
//این قسمت از کد ، به کد برنامه اضافه شده است . در طی بازی اگر کارتهای موجود در دست بازیکن(در این بازی یک بازیکن داریم که همان کاربر است و یک حریف که کامپیوتر میباشد) با کارت موجود در وسط زمینه ی بازی(discardPile) از نظر عددی و نوع(rank و suit) متفاوت باشد و یا در دست بازیکن عدد ۸ موجود نباشد ، بازیکن باید از دسته کارتی که در وسط زمینه ی بازی در کنار discardPile قرار دارد و بشکل پشت کارت نشان داده شده است(که همان drawCard میباشد) یک کارت جدید را به دست خود اضافه کند . حال اگر اضافه کردن کارتها بشکلی زیاد شود که از عرض صفحه نمایش بیشتر شود ، یک شکل در پایین سمت راست در امتداد اضافه شدن کارتها در صفحه نمایش داده میشود(nextCardButton) و میگوید که کارتهای بیشتری به دست اضافه شده اند(در ادامه با کلیک بر روی این شکل ، کارتهای پنهان شده به شکل چرخشی در صفحه نمایش داده میشوند و حرکت میکنند) :
 	if (myHand.size() > 7) {
			canvas.drawBitmap(nextCardButton, 
					screenW-nextCardButton.getWidth()-(30*scale), 
					screenH-nextCardButton.getHeight()-scaledCardH-(90*scale), 
					null);
		}




		for (int i = 0; i < myHand.size(); i++) {
			if (i == movingCardIdx) {
				canvas.drawBitmap(myHand.get(i).getBitmap(), 
						movingX, 
						movingY, 
						null);						
			} else {
				if (i < 7) {
					canvas.drawBitmap(myHand.get(i).getBitmap(), 
							i*(scaledCardW+5), 
							screenH-scaledCardH-whitePaint.getTextSize()-(50*scale), 
							null);							
				}
			}
		}			

 invalidate();
 
 
 
 
}
  
  
  
  public boolean onTouchEvent(MotionEvent event) {
 int eventaction = event.getAction();
 int X = (int)event.getX();
 int Y = (int)event.getY();
 switch (eventaction ) {
 case MotionEvent.ACTION_DOWN:
 if (myTurn) { 
 for (int i = 0; i < 7; i++) { 
 if (X > i*(scaledCardW+5) &&
 X < i*(scaledCardW+5)
 + scaledCardW &&
 Y > screenH-scaledCardH-
 whitePaint.getTextSize()-
(50*scale)) {
 movingCardIdx = i;
 movingX = X-(int)(30*scale); 
 movingY = Y-(int)(70*scale); 
 }
 }
 }
 break;
 case MotionEvent.ACTION_MOVE:
 movingX = X-(int)(30*scale); 
 movingY = Y-(int)(70*scale); 
 
 break;
 
 case MotionEvent.ACTION_UP:
 if (movingCardIdx > -1 && 
 X > (screenW/2)-(100*scale) && 
 X < (screenW/2)+(100*scale) &&
 Y > (screenH/2)-(100*scale) &&
 Y < (screenH/2)+(100*scale) &&
 (myHand.get(movingCardIdx).getRank() == 8 ||
 myHand.get(movingCardIdx).getRank() == 
validRank || 
 myHand.get(movingCardIdx).getSuit() == 
validSuit)) { 
 validRank = myHand.get 
 (movingCardIdx).getRank(); 
 validSuit = myHand.get 
 (movingCardIdx).getSuit(); 
 discardPile.add(0, myHand. 
get(movingCardIdx)); 
 myHand.remove(movingCardIdx); 
 
//در بخش قبل گفته شد که اگر کارتی از دست بازیکن به وسط زمینه کشیده شود و در محل اجرای بازی(discardPile) قرار بگیرد ، آن کارت اگر شرایط بازی را داشته باشد از دست بازیکن کم میشود و به discardPile اضافه میشود . حال اگر بازیکن یک کارت با شماره ۸ را بازی کند ، یک دیالوگ نمایش داده میشود(کد این دیالوگ در پایین صفحه آمده است) و میپرسد که چه نوعی از کارتها را انتخاب میکنید . هر نوعی که انتخاب شود بازیکن حریف میبایست همان کارتی از همان نوع را وارد بازی کند :
 if (validRank == 8) { 
 showChooseSuitDialog(); }
 
 }
 
 
 
 //این قطعه کد میگوید که اگر کارتی حرکت نکرده باشد(movingCardIdx == -1) و myTurn هم true باشد و نقطه ی لمس صفحه نمایش همان کارتی در وسط صفحه باشد که به پشت نمایش داده شده است(drawCard) آنگاه اگر کارتی درون دست بازیکن شرایط ورود به بازی را نداشت (checkForValidDraw()) پس یک کارت از drawCard به دستش اضافه شود . وگرنه یک Toast پیام میدهد که یک کارت شرایط ورود به بازی را دارد :
   	if (movingCardIdx == -1 && myTurn && 
		        		X > (screenW/2)-(100*scale) &&
		        		X < (screenW/2)+(100*scale) &&
		        		Y > (screenH/2)-(100*scale) &&
		        		Y < (screenH/2)+(100*scale)) {
	        		if (checkForValidDraw()) {
		        		drawCard(myHand);	        			
	        		} else {
	        			Toast.makeText(myContext, "You have a valid play.", Toast.LENGTH_SHORT).show();
	        		}
	        	}
//این قطعه کد میگوید که اگر شکلی که بمنظور اضافه شدن کارتها بشکل پنهان در نظر گرفته ایم لمس شد ، کارتهای اضافی بشکل چرخشی (و هر بار یک چرخش) در صفحه نشان داده شوند : 
	        	if (myHand.size() > 7 &&
	        		X > screenW-nextCardButton.getWidth()-(30*scale) &&
	        		Y > screenH-nextCardButton.getHeight()-scaledCardH-(90*scale) &&
	        		Y < screenH-nextCardButton.getHeight()-scaledCardH-(60*scale)) {
	        			Collections.rotate(myHand, 1);
	        	}
	        	
	        	
 
 movingCardIdx = -1;
 
 break;
 }
 invalidate();
 return true;
 }
  
  
  
  
  
	private void initCards() {
		for (int i = 0; i < 4; i++) {
			for (int j = 102; j < 115; j++) {
				int tempId = j + (i*100);
				Card tempCard = new Card(tempId);
				int resourceId = getResources().getIdentifier("card" + tempId, "drawable", myContext.getPackageName());
				Bitmap tempBitmap = BitmapFactory.decodeResource(myContext.getResources(), resourceId);
		        scaledCardW = (int) (screenW/8);
		        scaledCardH = (int) (scaledCardW*1.28);
				Bitmap scaledBitmap = Bitmap.createScaledBitmap(tempBitmap, scaledCardW, scaledCardH, false); 
				tempCard.setBitmap(scaledBitmap);
				deck.add(tempCard);
			}
		}
	}
  
  
  
  

	private void drawCard(List<Card> handToDraw) {
handToDraw.add(0, deck.get(0));
 deck.remove(0);
		if (deck.isEmpty()) {
	   for (int i = discardPile.size()-1; i > 0 ; i--) {
				deck.add(discardPile.get(i));
				discardPile.remove(i);
				Collections.shuffle(deck,new Random());
			}
		}
	}
	
	private void dealCards() {
		Collections.shuffle(deck,new Random());
		for (int i = 0; i < 7; i++) {
			drawCard(myHand);
			drawCard(oppHand);		
		}		
	}
  
  
 //این دستور یک دیالوگ طراحی میکند و شامل یک تیتر ، اسپینر و یک دکمه ی ok است . اسپینر به شکل یک لیست باز شونده است که از یک آداپتر برای نمایش آرایه ی چهار عضوی برای لیست خود استفاده میکند 
	private void showChooseSuitDialog() {
		final Dialog chooseSuitDialog = new Dialog(myContext);
		chooseSuitDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
		chooseSuitDialog.setContentView(R.layout.choose_suit_dialog);
    	final Spinner suitSpinner = (Spinner) chooseSuitDialog.findViewById(R.id.suitSpinner);
    	ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(
                myContext, R.array.suits, android.R.layout.simple_spinner_item);
    	adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
    	suitSpinner.setAdapter(adapter);
        Button okButton = (Button) chooseSuitDialog.findViewById(R.id.okButton);
        okButton.setOnClickListener(new View.OnClickListener(){
            public void onClick(View view){

//قطعه کد زیر مقدار suitText را تعیین میکند که درون Toast زیر برای نمایش یک پیام به کاربر استفاده میشود .
//هر سطر از لیست اسپینر یک پوزیشن دارد و از صفر شروع میشود پس آنرا +1 کرده ایم تا از 1 شروع شود . حال هر پوزیشنی که کلیک شود را در 100 ضرب کرده ایم که در این حالت برای سطر اول عدد 100 و برای سطر دوم عدد 200 و ... را میدهد که همان validSuit مورد نظر است :
            	validSuit = (suitSpinner.getSelectedItemPosition()+1)*100;
            	String suitText = "";
            	if (validSuit == 100) {
            		suitText = "Diamonds";
            	} else if (validSuit == 200) {
            		suitText = "Clubs";
            	} else if (validSuit == 300) {
            		suitText = "Hearts";
            	} else if (validSuit == 400) {
            		suitText = "Spades";
            	}
            	chooseSuitDialog.dismiss();
            	Toast.makeText(myContext, "You chose " + suitText, Toast.LENGTH_SHORT).show();

            }
        }); 
    	chooseSuitDialog.show();
	}
  
  
  
  
  //این قطعه کد متغیر Boolean canDraw را در صورت داشتن شرایط بازی برای یک کارت از کارتهای درون دست بازیکن ، برابر false قرار میدهد که در شرط if در دستور MotionEvent.ACTION_UP مورد نیاز است :
  
  private boolean checkForValidDraw() {
 boolean canDraw = true;
 for (int i = 0; i < myHand.size(); i++) {
 int tempId = myHand.get(i).getId();
 int tempRank = myHand.get(i).getRank();
 int tempSuit = myHand.get(i).getSuit();
 if (validSuit == tempSuit || validRank == tempRank
||
 tempId == 108 || tempId == 208 ||
 tempId == 308 || tempId == 408) {
 canDraw = false;
 }
 }
 return canDraw;
}
  
  
  
}
