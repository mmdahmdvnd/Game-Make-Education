import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import android.app.Dialog;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

//قسمتهای جدید که به کد بازی اضافه شده اند شرح داده میشوند . سایر قسمتهای کد در بخشهای قبل شرح داده شده اند :
public class GameView extends View{
  
  private Context myContext;
  
  private List<Card> deck = new ArrayList<Card>();
  private List<Card> myHand = new ArrayList<Card>();
  private List<Card> oppHand = new ArrayList<Card>();

  private List<Card> discardPile = new ArrayList<Card>();

  private int scaledCardW;
  private int scaledCardH;
  private int screenW;
  private int screenH;
  
  private float scale;
  
  private Paint whitePaint;
  
  private int oppScore;
  private int myScore;
  
  private Bitmap cardBack;
  
  private boolean myTurn;
  
  private int movingCardIdx = -1;
  private int movingX;
  private int movingY;
  
  private int validSuit;
  private int validRank;

  private Bitmap nextCardButton;
  
  private Boolean canDraw;

//از کلاس ComputerPlayer یک نمونه(شئ) میسازیم :
  private ComputerPlayer computerPlayer = new ComputerPlayer();
  
  
  public GameView(Context context){
    super(context);
    myContext = context;
    scale = myContext.getResources().getDisplayMetrics().
density;
 whitePaint = new Paint(); 
 whitePaint.setAntiAlias(true); 
 whitePaint.setColor(Color.WHITE);
 whitePaint.setStyle(Paint.Style.STROKE);
 whitePaint.setTextAlign(Paint.Align.LEFT);
 whitePaint.setTextSize(scale*15);
 
  }
  
  
  
    @Override
    public void onSizeChanged (int w, int h, int oldw, int oldh){
        super.onSizeChanged(w, h, oldw, oldh);
        screenW = w;
        screenH = h;
     
     initCards();
     
     dealCards();
     
   drawCard(discardPile);
     
     Bitmap tempBitmap = 
BitmapFactory.decodeResource
(myContext.getResources(),
R.drawable.card_back);
scaledCardW = (int) (screenW/8);
scaledCardH = (int) (scaledCardW*1.28);
cardBack = Bitmap.createScaledBitmap
(tempBitmap, scaledCardW, 
scaledCardH,false);


validSuit = discardPile.get(0).getSuit(); 
 validRank = discardPile.get(0).getRank();
 
 
	nextCardButton = BitmapFactory.decodeResource(getResources(), R.drawable.arrow_next); 
	
//این قسمت بمنظور تعیین کردن دور بازی - در اولین اجرای بازی - بین بازیکن و کامپیوتر که کدامیک شروع کننده بازی باشند ، myTurn را بشکل اتفاقی مقدار true و یا false میدهد . اگر myTurn! مقدار true باشد پس متد فراخوانی شده و کامپیوتر شروع کننده ی بازی است :
		myTurn = new Random().nextBoolean();
		if (!myTurn) {
			makeComputerPlay();			
		}
	
       }
       
       
  
  protected void onDraw(Canvas canvas){
    
    	canvas.drawRGB(97,168,32);
    
   		canvas.drawText("Computer Score: " + Integer.toString(oppScore), 10, whitePaint.getTextSize()+10, whitePaint);		
		canvas.drawText("My Score: " + Integer.toString(myScore), 10, screenH-whitePaint.getTextSize()-30, whitePaint);
  
  
  
  for (int i = 0; i < myHand.size(); i++) {
 if (i < 7) {
 canvas.drawBitmap(myHand.get(i).getBitmap(),
 i*(scaledCardW+5),
 screenH-scaledCardH-
 whitePaint.getTextSize()-(50*scale),
 null);
 }
 }
 
 for (int i = 0; i < oppHand.size(); i++) {
 canvas.drawBitmap(cardBack,
 i*(scale*5),
 whitePaint.getTextSize()+(50*scale),
 null);
}
 
 
 canvas.drawBitmap(cardBack, 
(screenW/2)-cardBack.getWidth()-10, 
(screenH/2)-(cardBack.getHeight()/2), null);
 
 
 
   if (!discardPile.isEmpty()) {
  canvas.drawBitmap(discardPile.get(0).getBitmap(),
(screenW/2)+10,
(screenH/2)-(cardBack.getHeight()/2),
null);
    } 
 
 
 	if (myHand.size() > 7) {
			canvas.drawBitmap(nextCardButton, 
					screenW-nextCardButton.getWidth()-(30*scale), 
					screenH-nextCardButton.getHeight()-scaledCardH-(90*scale), 
					null);
		}
		for (int i = 0; i < myHand.size(); i++) {
			if (i == movingCardIdx) {
				canvas.drawBitmap(myHand.get(i).getBitmap(), 
						movingX, 
						movingY, 
						null);						
			} else {
				if (i < 7) {
					canvas.drawBitmap(myHand.get(i).getBitmap(), 
							i*(scaledCardW+5), 
							screenH-scaledCardH-whitePaint.getTextSize()-(50*scale), 
							null);							
				}
			}
		}			

 invalidate();
 
}
  
  
  
  public boolean onTouchEvent(MotionEvent event) {
 int eventaction = event.getAction();
 int X = (int)event.getX();
 int Y = (int)event.getY();
 switch (eventaction ) {
 case MotionEvent.ACTION_DOWN:
 if (myTurn) { 
 for (int i = 0; i < 7; i++) { 
 if (X > i*(scaledCardW+5) &&
 X < i*(scaledCardW+5)
 + scaledCardW &&
 Y > screenH-scaledCardH-
 whitePaint.getTextSize()-
(50*scale)) {
 movingCardIdx = i;
 movingX = X-(int)(30*scale); 
 movingY = Y-(int)(70*scale); 
 }
 }
 }
 break;
 case MotionEvent.ACTION_MOVE:
 movingX = X-(int)(30*scale); 
 movingY = Y-(int)(70*scale); 
 
 break;
 
 case MotionEvent.ACTION_UP:
 if (movingCardIdx > -1 && 
 X > (screenW/2)-(100*scale) && 
 X < (screenW/2)+(100*scale) &&
 Y > (screenH/2)-(100*scale) &&
 Y < (screenH/2)+(100*scale) &&
 (myHand.get(movingCardIdx).getRank() == 8 ||
 myHand.get(movingCardIdx).getRank() == 
validRank || 
 myHand.get(movingCardIdx).getSuit() == 
validSuit)) { 
 validRank = myHand.get 
 (movingCardIdx).getRank(); 
 validSuit = myHand.get 
 (movingCardIdx).getSuit(); 
 discardPile.add(0, myHand. 
get(movingCardIdx)); 
 myHand.remove(movingCardIdx); 
 
							if (validRank == 8) {
		  	showChooseSuitDialog();							
							} else {

//این قطعه کد به کد در بخش قبل اضافه شده است . متد ()makeComputerPlay که در انتهای کد آمده است فراخوانی میشود :
								myTurn = false;
						makeComputerPlay();							
							}							
						
 }
 
   	if (movingCardIdx == -1 && myTurn && 
		        		X > (screenW/2)-(100*scale) &&
		        		X < (screenW/2)+(100*scale) &&
		        		Y > (screenH/2)-(100*scale) &&
		        		Y < (screenH/2)+(100*scale)) {
	        		if (checkForValidDraw()) {
		        		drawCard(myHand);	        			
	        		} else {
	        			Toast.makeText(myContext, "You have a valid play.", Toast.LENGTH_SHORT).show();
	        		}
	        	}
	        	if (myHand.size() > 7 &&
	        		X > screenW-nextCardButton.getWidth()-(30*scale) &&
	        		Y > screenH-nextCardButton.getHeight()-scaledCardH-(90*scale) &&
	        		Y < screenH-nextCardButton.getHeight()-scaledCardH-(60*scale)) {
	        			Collections.rotate(myHand, 1);
	        	}
	        	
	        
 movingCardIdx = -1;
 
 break;
 }
 invalidate();
 return true;
 }
  
  
  
  
  
	private void initCards() {
		for (int i = 0; i < 4; i++) {
			for (int j = 102; j < 115; j++) {
				int tempId = j + (i*100);
				Card tempCard = new Card(tempId);
				int resourceId = getResources().getIdentifier("card" + tempId, "drawable", myContext.getPackageName());
				Bitmap tempBitmap = BitmapFactory.decodeResource(myContext.getResources(), resourceId);
		        scaledCardW = (int) (screenW/8);
		        scaledCardH = (int) (scaledCardW*1.28);
				Bitmap scaledBitmap = Bitmap.createScaledBitmap(tempBitmap, scaledCardW, scaledCardH, false); 
				tempCard.setBitmap(scaledBitmap);
				deck.add(tempCard);
			}
		}
	}
  
  
  
  

	private void drawCard(List<Card> handToDraw) {
handToDraw.add(0, deck.get(0));
 deck.remove(0);
		if (deck.isEmpty()) {
	   for (int i = discardPile.size()-1; i > 0 ; i--) {
				deck.add(discardPile.get(i));
				discardPile.remove(i);
				Collections.shuffle(deck,new Random());
			}
		}
	}
	
	private void dealCards() {
		Collections.shuffle(deck,new Random());
		for (int i = 0; i < 7; i++) {
			drawCard(myHand);
			drawCard(oppHand);		
		}		
	}
  
  
  
	private void showChooseSuitDialog() {
		final Dialog chooseSuitDialog = new Dialog(myContext);
		chooseSuitDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
		chooseSuitDialog.setContentView(R.layout.choose_suit_dialog);
    	final Spinner suitSpinner = (Spinner) chooseSuitDialog.findViewById(R.id.suitSpinner);
    	ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(
                myContext, R.array.suits, android.R.layout.simple_spinner_item);
    	adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
    	suitSpinner.setAdapter(adapter);
        Button okButton = (Button) chooseSuitDialog.findViewById(R.id.okButton);
        okButton.setOnClickListener(new View.OnClickListener(){
            public void onClick(View view){
            	validSuit = (suitSpinner.getSelectedItemPosition()+1)*100;
            	String suitText = "";
            	if (validSuit == 100) {
            		suitText = "Diamonds";
            	} else if (validSuit == 200) {
            		suitText = "Clubs";
            	} else if (validSuit == 300) {
            		suitText = "Hearts";
            	} else if (validSuit == 400) {
            		suitText = "Spades";
            	}
            	chooseSuitDialog.dismiss();
            	Toast.makeText(myContext, "You chose " + suitText, Toast.LENGTH_SHORT).show();

            }
        }); 
    	chooseSuitDialog.show();
	}
  
  
  
  
  
  
  private boolean checkForValidDraw() {
 boolean canDraw = true;
 for (int i = 0; i < myHand.size(); i++) {
 int tempId = myHand.get(i).getId();
 int tempRank = myHand.get(i).getRank();
 int tempSuit = myHand.get(i).getSuit();
 if (validSuit == tempSuit || validRank == tempRank
||
 tempId == 108 || tempId == 208 ||
 tempId == 308 || tempId == 408) {
 canDraw = false;
 }
 }
 return canDraw;
}
  
  
  
  
  
	private void makeComputerPlay() {
		int tempPlay = 0;
		while (tempPlay == 0) {
//متد makePlay از کلاس computerPlayer فراخوانی شده و مقدار برگشتی از این کلاس و متد آن ، در tempPlay قرار میگیرد که این مقدار ،  آی دی(id) کارتی است که به وسط محیط بازی کشیده میشود و اگر شرایط بازی را داشته باشد ، توسط کلاس computerPlayer بعنوان کارتی که play میشود تعیین خواهد شد : 
			tempPlay = computerPlayer.makePlay(oppHand, validSuit, validRank);
//اگر کارتی در دست کامپیوتر ، شرایط بازی را نداشت(شرایط بازی این است که کارت هم شماره و یا هم نوع کارتی که در وسط زمینه ی بازی قرار دارد(discardPile) باشد و یا یک کارت با شماره ی ۸ باشد) کارتی از drawCard وارد دست کامپیوتر میشود(در حالتی که بازیکن در حال بازی باشد بصورت دستی کارتی را باید از drawCard وارد دست خود کند ولی در اینجا بصورت خودکار صورت میگیرد) :
			if (tempPlay == 0) {
				drawCard(oppHand);
			}
		}
//اگر یک ۸ وارد بازی شود چه کامپیوتر و چه بازیکن هر کدام که نوبت بازی آنها باشد باید تعیین کنند که حریف باید کارتی از چه نوع(suit) را وارد بازی کند پس :
//اگر مقدار برگشتی از کلاس computerPlayer برای tempPlay عددی با شماره ی ۸ باشد ، توسط متد chooseSuit از کلاس computerPlayer تعیین میشود که حریف چه کارتی وارد کند :
		if (tempPlay == 108 || tempPlay == 208 || tempPlay == 308 || tempPlay == 408) {
			validRank = 8;
			validSuit = computerPlayer.chooseSuit(oppHand);
			String suitText = "";
        	if (validSuit == 100) {
        		suitText = "Diamonds";
        	} else if (validSuit == 200) {
        		suitText = "Clubs";
        	} else if (validSuit == 300) {
        		suitText = "Hearts";
        	} else if (validSuit == 400) {
        		suitText = "Spades";
        	}
        	Toast.makeText(myContext, "Computer chose " + suitText, Toast.LENGTH_SHORT).show();
		} else {
//دستور else میگوید که اگر یک کارت با شماره ی ۸ بازی نشد پس مقدار valudSuit و validRank را برای کارت با آی دی tempPlay ، محاسبه میکنیم و با دستور for برای همه ی کارتهای موجود در دست کامپیوتر ، اگر کارتی از آنها هم شماره و یا هم نوع با کارت tempPlay بود ، آن کارت از دست کامپیوتر کم شده و به discardPile اضافه میشود :
			validSuit = Math.round((tempPlay/100) * 100);
			validRank = tempPlay - validSuit; 
		}
		for (int i = 0; i < oppHand.size(); i++) {
			Card tempCard = oppHand.get(i);
			if (tempPlay == tempCard.getId()) {
		 		discardPile.add(0, oppHand.get(i));
				oppHand.remove(i);				
			}
		}
		myTurn = true;
	}
	
  
  
}
