
import java.util.Random;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.media.AudioManager;
import android.media.SoundPool;
import android.os.Handler;
import android.os.Message;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

//در این قسمت و این کد ، علاوه بر تصویر تیتر و تصویر زمینه ی برنامه ، تصویر هفت mole (موش کور) در صفحه طراحی میشود :
public class WhackAMoleView extends SurfaceView implements SurfaceHolder.Callback {
    
    private Context myContext;
    private SurfaceHolder mySurfaceHolder;
    private Bitmap backgroundImg;
    private int backgroundOrigW;
    private int backgroundOrigH;
    private float scaleW;
    private float scaleH;
    private float drawScaleW;
    private float drawScaleH;
    private Bitmap mask;
    private Bitmap mole;

//تعریف متغیرهایی بجهت طول و عرض نقطه ی نمایش moleها :
    private int mole1x, mole2x, mole3x, mole4x, mole5x, mole6x, mole7x;
    private int mole1y, mole2y, mole3y, mole4y, mole5y, mole6y, mole7y;

    private int screenW = 1;
    private int screenH = 1;
    private boolean running = false;
    private boolean onTitle = true;
  
    private WhackAMoleThread thread;
	
	public WhackAMoleView(Context context, AttributeSet attrs) {
        super(context, attrs);

        SurfaceHolder holder = getHolder();
        holder.addCallback(this);

        thread = new WhackAMoleThread(holder, context, new Handler() {
            @Override
            public void handleMessage(Message m) {
            }
        });

        setFocusable(true); 
    }
    

	public WhackAMoleThread getThread() {
		return thread;
	}
	
	
	
	
	class WhackAMoleThread extends Thread {
		
        public WhackAMoleThread(SurfaceHolder surfaceHolder, Context context,
                Handler handler) {
            mySurfaceHolder = surfaceHolder;
            myContext = context;
            backgroundImg = BitmapFactory.decodeResource(context.getResources(), R.drawable.title);
    		backgroundOrigW = backgroundImg.getWidth();
    		backgroundOrigH = backgroundImg.getHeight(); 	
        }
        @Override
        public void run() {
            while (running) {
                Canvas c = null;
                try {
                    c = mySurfaceHolder.lockCanvas(null);
                    synchronized (mySurfaceHolder) {
                    
                        draw(c);
                    }
                } finally {
                    if (c != null) {
                        mySurfaceHolder.unlockCanvasAndPost(c);
                    }
                }
            }
        }
        
        
        
        
        
  //در این متد توسط Bitmap هفت موش کور را در هفت قسمت از صفحه نمایش میدهیم :   
        private void draw(Canvas canvas) {
        	try {
        		canvas.drawBitmap(backgroundImg, 0, 0, null);
        		if (!onTitle) {
            		
            		canvas.drawBitmap(mole, mole1x, mole1y, null);
                    canvas.drawBitmap(mole, mole2x, mole2y, null);
                    canvas.drawBitmap(mole, mole3x, mole3y, null);
                    canvas.drawBitmap(mole, mole4x, mole4y, null);
                    canvas.drawBitmap(mole, mole5x, mole5y, null);
                    canvas.drawBitmap(mole, mole6x, mole6y, null);
                    canvas.drawBitmap(mole, mole7x, mole7y, null); 

//در این قسمت ماسکهایی(mask) که روی موشهای طراحی شده را میپوشاند و همرنگ زمینه ی بازی است ، طراحی میشوند . کاربرد این ماسکها این است که : همواره و در هر بار رندر شدن و طراحی صفحه ، همه ی موشها را نمایش میدهیم و تنها موشی که حرکت میکند را با تغییر طول و عرض نقطه ی نمایش آن ، مقداردهی میکنیم . یعنی اینکار باعث میشود که کد نویسی اضافه نداشته باشیم . این ماسکها را کامنت کرده ایم که بتوان موشها را ببینید :
                    /*
            		canvas.drawBitmap(mask, (int) 50*drawScaleW, (int) 450*drawScaleH, null);
            		canvas.drawBitmap(mask, (int)150*drawScaleW, (int) 400*drawScaleH, null);
                    canvas.drawBitmap(mask, (int)250*drawScaleW, (int) 450*drawScaleH, null);
            		canvas.drawBitmap(mask, (int)350*drawScaleW, (int) 400*drawScaleH, null);
                    canvas.drawBitmap(mask, (int)450*drawScaleW, (int) 450*drawScaleH, null);
            		canvas.drawBitmap(mask, (int)550*drawScaleW, (int) 400*drawScaleH, null);
                    canvas.drawBitmap(mask, (int)650*drawScaleW, (int) 450*drawScaleH, null);        			
                    */
        		}
             
             
        	} catch (Exception e) {
        	}
        }
        
        
        
        
        
        
        
        
        boolean doTouchEvent(MotionEvent event) {
            synchronized (mySurfaceHolder) {
    	        int eventaction = event.getAction();   
    	        int X = (int)event.getX();
    	        int Y = (int)event.getY();

    	        switch (eventaction ) {

    	        case MotionEvent.ACTION_DOWN:
    	          	        		
    	        	
    	        	break;

    	        case MotionEvent.ACTION_MOVE: 
    	        	break;
    	        	
    	        case MotionEvent.ACTION_UP:
    	        	if (onTitle) {
    	        		backgroundImg = BitmapFactory.decodeResource(myContext.getResources(), R.drawable.background);
    	        		backgroundImg = Bitmap.createScaledBitmap(backgroundImg, screenW, screenH, true);

//مقداردهی Bitmap های نمایش دهنده ی ماسکها و موشها :
    	                mask = BitmapFactory.decodeResource(myContext.getResources(), R.drawable.mask);
    	                mole = BitmapFactory.decodeResource(myContext.getResources(), R.drawable.mole);
  
//تعیین یک متغیر برای تعیین ابعاد ماسکها و موشها . که این ابعاد نسبتی از عرض و طول صفحه ی نمایش میباشند :  	            
    	                scaleW = (float) screenW/ (float) backgroundOrigW;
    	                scaleH = (float) screenH/ (float) backgroundOrigH;

//تعیین Bitmap ها با مقیاسی که مورد نظر است :
    	                mask = Bitmap.createScaledBitmap(mask, (int)(mask.getWidth()*scaleW), (int)(mask.getHeight()*scaleH), true);
    	                mole = Bitmap.createScaledBitmap(mole, (int)(mole.getWidth()*scaleW), (int)(mole.getHeight()*scaleH), true);
    	                
    	      onTitle = false;
        
    	       
    	        	break;   	
    	    } 	
    	        }
    	    }
            return true;
        }
        
        
        
        
     //این متد قبل از متد ()draw  فراخوانی شده و ابعاد را بجهت نمایش mole ها(موشها)  مقداردهی میکند . این ابعاد طبق تصویر نمایش دهنده ی محل قرارگیری موشها تعیین شده اند : 
        public void setSurfaceSize(int width, int height) {
            synchronized (mySurfaceHolder) {
                screenW = width;
                screenH = height;
                backgroundImg = Bitmap.createScaledBitmap(backgroundImg, width, height, true);
                drawScaleW = (float) screenW / 800;
                drawScaleH = (float) screenH / 600;
        		mole1x = (int) (55*drawScaleW);
        		mole2x = (int) (155*drawScaleW);
        		mole3x = (int) (255*drawScaleW);
        		mole4x = (int) (355*drawScaleW);
        		mole5x = (int) (455*drawScaleW);
        		mole6x = (int) (555*drawScaleW);
        		mole7x = (int) (655*drawScaleW);
        		mole1y = (int) (475*drawScaleH);
        		mole2y = (int) (425*drawScaleH);
        		mole3y = (int) (475*drawScaleH);
        		mole4y = (int) (425*drawScaleH);
        		mole5y = (int) (475*drawScaleH);
        		mole6y = (int) (425*drawScaleH);
        		mole7y = (int) (475*drawScaleH);
        		
        		
        		
            }
        }

        public void setRunning(boolean b) {
            running = b;
        }
        
    }
	
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        return thread.doTouchEvent(event);
    }
	
	@Override
	public void surfaceChanged(SurfaceHolder holder, int format, int width,
			int height) {
		thread.setSurfaceSize(width, height);
	}

	@Override
	public void surfaceCreated(SurfaceHolder holder){
		thread.setRunning(true);
		if (thread.getState() == Thread.State.NEW ){
			thread.start();
		}
	}
	
	@Override
    public void surfaceDestroyed(SurfaceHolder holder) {
      thread.setRunning(false);
    }
	
	
}
