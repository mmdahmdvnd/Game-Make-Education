import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import android.app.Dialog;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

//قسمتهای جدید که به کد بازی اضافه شده اند شرح داده میشوند . سایر قسمتهای کد در بخشهای قبل شرح داده شده اند :
public class GameView extends View{
  
  private Context myContext;
  
  private List<Card> deck = new ArrayList<Card>();
  private List<Card> myHand = new ArrayList<Card>();
  private List<Card> oppHand = new ArrayList<Card>();

  private List<Card> discardPile = new ArrayList<Card>();

  private int scaledCardW;
  private int scaledCardH;
  private int screenW;
  private int screenH;
  
  private float scale;
  
  private Paint whitePaint;
  
  private int oppScore;
  private int myScore;
  
  private Bitmap cardBack;
  
// این متغیر به منظور چرخش دست بازی بین دو بازیکن بکار میرود :
  private boolean myTurn;
  
//این متغیر بعنوان شناسه ای برای کارتی که در صفحه حرکت میکند بکار میرود :
  private int movingCardIdx = -1;
  private int movingX;
  private int movingY;
  
//دو متغیر جهت نمایش ویژگی کارت موجود در discardPile : 
  private int validSuit;
  private int validRank;

  
  
  public GameView(Context context){
    super(context);
    myContext = context;
    scale = myContext.getResources().getDisplayMetrics().
density;
 whitePaint = new Paint(); 
 whitePaint.setAntiAlias(true); 
 whitePaint.setColor(Color.WHITE);
 whitePaint.setStyle(Paint.Style.STROKE);
 whitePaint.setTextAlign(Paint.Align.LEFT);
 whitePaint.setTextSize(scale*15);

 //در سازنده ی کلاس در ابتدای بازی این متغیر را بصورت پیشفرض برابر true قرار میدهیم :
 myTurn = true;
  }
  
  
  
    @Override
    public void onSizeChanged (int w, int h, int oldw, int oldh){
        super.onSizeChanged(w, h, oldw, oldh);
        screenW = w;
        screenH = h;
     
     initCards();
     
     dealCards();
     
   drawCard(discardPile);
     
     Bitmap tempBitmap = 
BitmapFactory.decodeResource
(myContext.getResources(),
R.drawable.card_back);
scaledCardW = (int) (screenW/8);
scaledCardH = (int) (scaledCardW*1.28);
cardBack = Bitmap.createScaledBitmap
(tempBitmap, scaledCardW, 
scaledCardH,false);

//دو متغیر برای کارتی که در discardPile در وسط سمت راست صفحه قرار دارد و بازی طبق این کارت شروع میشود :
validSuit = discardPile.get(0).getSuit(); 
 validRank = discardPile.get(0).getRank();

       }
       
       
  // قسمتهای ابتدایی از متد ()onDraw که در زیر آمده اند ، صفحه ی بازی را طراحی میکنند :
  protected void onDraw(Canvas canvas){
    
    canvas.drawRGB(210,105,0);
    
   		canvas.drawText("Computer Score: " + Integer.toString(oppScore), 10, whitePaint.getTextSize()+10, whitePaint);		
		canvas.drawText("My Score: " + Integer.toString(myScore), 10, screenH-whitePaint.getTextSize()-30, whitePaint);
  
  
  
  for (int i = 0; i < myHand.size(); i++) {
 if (i < 7) {
 canvas.drawBitmap(myHand.get(i).getBitmap(),
 i*(scaledCardW+5),
 screenH-scaledCardH-
 whitePaint.getTextSize()-(50*scale),
 null);
 }
 }
 
 for (int i = 0; i < oppHand.size(); i++) {
 canvas.drawBitmap(cardBack,
 i*(scale*5),
 whitePaint.getTextSize()+(50*scale),
 null);
}
 
 
 canvas.drawBitmap(cardBack, 
(screenW/2)-cardBack.getWidth()-10, 
(screenH/2)-(cardBack.getHeight()/2), null);
 
 
 
   if (!discardPile.isEmpty()) {
  canvas.drawBitmap(discardPile.get(0).getBitmap(),
(screenW/2)+10,
(screenH/2)-(cardBack.getHeight()/2),
null);
    } 
 
 
 // این قسمت از این متد مقدار movingCardIdx که از متد ()onTouchEvent میاید را بررسی میکند و اگر این مقدار برابر شماره ی تعداد کارتهای موجود در دست بازیکن بود ، همان کارت با همان شماره در لیست را در مختصات movingX و movingY نمایش میدهد و چون متد ()invalidate در پایان متد آمده پس مرتبا متد onDraw فراخوانی شده و با حرکت انگشت در صفحه نمایش تصویر در جهت این حرکت ایجاد شده و حرکت میکند . دستور بعد از else نیز میگوید که اگر i با movingCardIdx برابر نبود ، کارتی که حرکت کرده را دوباره به جای خودش برگردان :

 for (int i = 0; i < myHand.size(); i++) {
 if (i == movingCardIdx) { 
 canvas.drawBitmap(myHand.get(i).getBitmap(),
 movingX,
 movingY,
 null);
 } else { 
 canvas.drawBitmap
 (myHand.get(i).getBitmap(),
 i*(scaledCardW+5),
 screenH-scaledCardH-
 whitePaint.getTextSize()-
(50*scale), null); 
 }
 }
 invalidate();
 
 
 
 
}
  
  
  
  public boolean onTouchEvent(MotionEvent event) {
 int eventaction = event.getAction();
 int X = (int)event.getX();
 int Y = (int)event.getY();
 switch (eventaction ) {
 case MotionEvent.ACTION_DOWN:
 if (myTurn) { 
 for (int i = 0; i < 7; i++) { 

//این قسمت از کد میگوید که اگر در محلی که هر کارت (از دست بازیکن) در آنجا نمایش داده شده کلیک شد ، شماره ی این کارت در لیست خودش ، در متغیر movingCardIdx قرار داده شود :
 if (X > i*(scaledCardW+5) &&
 X < i*(scaledCardW+5)
 + scaledCardW &&
 Y > screenH-scaledCardH-
 whitePaint.getTextSize()-
(50*scale)) {
 movingCardIdx = i;

//مختصات نقطه ی لمس در این دو متغیر قرار میگیرند . مقدار 30*scale به این منظور آمده که نقطه ای که تصویر در آنجا نمایش داده میشود ، چند پیکسل از نقطه ی لمس صفحه فاصله داشته باشد تا تصویر در زیر انگشت پنهان نماند :
 movingX = X-(int)(30*scale); 
 movingY = Y-(int)(70*scale); 
 }
 }
 }
 break;
//مختصات نقطه ی حرکت کارت تعیین میشود :
 case MotionEvent.ACTION_MOVE:
 movingX = X-(int)(30*scale); 
 movingY = Y-(int)(70*scale); 
 
 break;
 
//هر بار که یک کارت را از داخل دست بازیکن به طرف وسط صفحه بکشید و انگشت را بردارید ، این قسمت فراخوانی شده و اگر کارتی در دست باشد(movingCardIdx > -1) و محل برداشتن انگشت همان محل discardPile باشد و کارت عدد شماره ۸ باشد و یا شماره کارت با شماره ی یا نوع کارت موجود در discardPile یک باشد ، آنگاه آن کارت برداشته شده به discardPile اضافه شده و از دست بازیکن کم میشود :
 case MotionEvent.ACTION_UP:
 if (movingCardIdx > -1 && 
 X > (screenW/2)-(100*scale) && 
 X < (screenW/2)+(100*scale) &&
 Y > (screenH/2)-(100*scale) &&
 Y < (screenH/2)+(100*scale) &&
 (myHand.get(movingCardIdx).getRank() == 8 ||
 myHand.get(movingCardIdx).getRank() == 
validRank || 
 myHand.get(movingCardIdx).getSuit() == 
validSuit)) { 
 validRank = myHand.get 
 (movingCardIdx).getRank(); 
 validSuit = myHand.get 
 (movingCardIdx).getSuit(); 
 discardPile.add(0, myHand. 
get(movingCardIdx)); 
 myHand.remove(movingCardIdx); 
 }
 movingCardIdx = -1;
 
 break;
 }
 invalidate();
 return true;
 }
  
  
  
  
  
	private void initCards() {
		for (int i = 0; i < 4; i++) {
			for (int j = 102; j < 115; j++) {
				int tempId = j + (i*100);
				Card tempCard = new Card(tempId);
				int resourceId = getResources().getIdentifier("card" + tempId, "drawable", myContext.getPackageName());
				Bitmap tempBitmap = BitmapFactory.decodeResource(myContext.getResources(), resourceId);
		        scaledCardW = (int) (screenW/8);
		        scaledCardH = (int) (scaledCardW*1.28);
				Bitmap scaledBitmap = Bitmap.createScaledBitmap(tempBitmap, scaledCardW, scaledCardH, false); 
				tempCard.setBitmap(scaledBitmap);
				deck.add(tempCard);
			}
		}
	}
  

	private void drawCard(List<Card> handToDraw) {
handToDraw.add(0, deck.get(0));
 deck.remove(0);
	}
	
	private void dealCards() {
		Collections.shuffle(deck,new Random());
		for (int i = 0; i < 7; i++) {
			drawCard(myHand);
			drawCard(oppHand);
			
		}		
	}
  
  
  
  
  
}
